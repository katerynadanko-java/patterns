"# patterns" 
https://refactoring.guru/ru/design-patterns

Абстрактная фабрика — это порождающий паттерн проектирования, который решает проблему создания целых семейств 
связанных продуктов, без указания конкретных классов продуктов.
Абстрактная фабрика задаёт интерфейс создания всех доступных типов продуктов, а каждая конкретная реализация 
фабрики порождает продукты одной из вариаций. Клиентский код вызывает методы фабрики для получения продуктов, 
вместо самостоятельного создания с помощью оператора new. При этом фабрика сама следит за тем, чтобы создать 
продукт нужной вариации.

Строитель — это порождающий паттерн проектирования, который позволяет создавать объекты пошагово.
В отличие от других порождающих паттернов, Строитель позволяет производить различные продукты, используя 
один и тот же процесс строительства.

Фабричный метод — это порождающий паттерн проектирования, который решает проблему создания различных продуктов, 
без указания конкретных классов продуктов.
Фабричный метод задаёт метод, который следует использовать вместо вызова оператора new для создания объектов-
продуктов. Подклассы могут переопределить этот метод, чтобы изменять тип создаваемых продуктов.

Прототип — это порождающий паттерн, который позволяет копировать объекты любой сложности без привязки к их 
конкретным классам.
Все классы—Прототипы имеют общий интерфейс. Поэтому вы можете копировать объекты, не обращая внимания на их 
конкретные типы и всегда быть уверены, что получите точную копию. Клонирование совершается самим объектом-
прототипом, что позволяет ему скопировать значения всех полей, даже приватных.

Одиночка — это порождающий паттерн, который гарантирует существование только одного объекта определённого класса, 
а также позволяет достучаться до этого объекта из любого места программы.
Одиночка имеет такие же преимущества и недостатки, что и глобальные переменные. Его невероятно удобно использовать, 
но он нарушает модульность вашего кода.
Вы не сможете просто взять и использовать класс, зависящий от одиночки в другой программе. Для этого придётся 
эмулировать присутствие одиночки и там. Чаще всего эта проблема проявляется при написании юнит-тестов.


Адаптер — это структурный паттерн, который позволяет подружить несовместимые объекты.
Адаптер выступает прослойкой между двумя объектами, превращая вызовы одного в вызовы понятные другому.

Мост — это структурный паттерн, который разделяет бизнес-логику или большой класс на несколько отдельных иерархий, 
которые потом можно развивать отдельно друг от друга.
Одна из этих иерархий (абстракция) получит ссылку на объекты другой иерархии (реализация) и будет делегировать им 
основную работу. Благодаря тому, что все реализации будут следовать общему интерфейсу, их можно будет взаимозаменять 
внутри абстракции.

Компоновщик — это структурный паттерн, который позволяет создавать дерево объектов и работать с ним так же, как и с 
единичным объектом.
Компоновщик давно стал синонимом всех задач, связанных с построением дерева объектов. Все операции компоновщика 
основаны на рекурсии и «суммировании» результатов на ветвях дерева.

Декоратор — это структурный паттерн, который позволяет добавлять объектам новые поведения на лету, помещая их в 
объекты-обёртки.
Декоратор позволяет оборачивать объекты бесчисленное количество раз благодаря тому, что и обёртки, и реальные оборачиваемые 
объекты имеют общий интерфейс.

Фасад — это структурный паттерн, который предоставляет простой (но урезанный) интерфейс к сложной системе объектов, 
библиотеке или фреймворку.
Кроме того, что Фасад позволяет снизить общую сложность программы, он также помогает вынести код, зависимый от внешней 
системы в единственное место.

Легковес — это структурный паттерн, который экономит память, благодаря разделению общего состояния, вынесенного в один 
объект, между множеством объектов.
Легковес позволяет экономить память, кешируя одинаковые данные, используемые в разных объектах.

Заместитель — это объект, который выступает прослойкой между клиентом и реальным сервисным объектом. Заместитель получает 
вызовы от клиента, выполняет свою функцию (контроль доступа, кеширование, изменение запроса и прочее), а затем передаёт 
вызов сервисному объекту.
Заместитель имеет тот же интерфейс, что и реальный объект, поэтому для клиента нет разницы — работать через заместителя 
или напрямую.

Цепочка обязанностей — это поведенческий паттерн, позволяющий передавать запрос по цепочке потенциальных обработчиков, 
пока один из них не обработает запрос.
Избавляет от жёсткой привязки отправителя запроса к его получателю, позволяя выстраивать цепь из различных обработчиков 
динамически.

Итератор — это поведенческий паттерн, позволяющий последовательно обходить сложную коллекцию, без раскрытия деталей 
её реализации.
Благодаря Итератору, клиент может обходить разные коллекции одним и тем же способом, используя единый интерфейс 
итераторов.

Снимок — это поведенческий паттерн, позволяющий делать снимки внутреннего состояния объектов, а затем восстанавливать 
их.
При этом Снимок не раскрывает подробностей реализации объектов, и клиент не имеет доступа к защищённой информации объекта.

Состояние — это поведенческий паттерн, позволяющий динамически изменять поведение объекта при смене его состояния.
Поведения, зависящие от состояния, переезжают в отдельные классы. Первоначальный класс хранит ссылку на один из таких 
объектов-состояний и делегирует ему работу.

Шаблонный метод — это поведенческий паттерн, задающий скелет алгоритма в суперклассе и заставляющий подклассы реализовать 
конкретные шаги этого алгоритма.

Команда — это поведенческий паттерн, позволяющий заворачивать запросы или простые операции в отдельные объекты.
Это позволяет откладывать выполнение команд, выстраивать их в очереди, а также хранить историю и делать отмену.

Посредник — это поведенческий паттерн, который упрощает коммуникацию между компонентами системы.
Посредник убирает прямые связи между отдельными компонентами, заставляя их общаться друг с другом через себя.

Наблюдатель — это поведенческий паттерн, который позволяет объектам оповещать другие объекты об изменениях 
своего состояния.
При этом наблюдатели могут свободно подписываться и отписываться от этих оповещений.

Стратегия — это поведенческий паттерн, выносит набор алгоритмов в собственные классы и делает их взаимозаменимыми.
Другие объекты содержат ссылку на объект-стратегию и делегируют ей работу. Программа может подменить этот объект 
другим, если требуется иной способ решения задачи.

Посетитель — это поведенческий паттерн, который позволяет добавить новую операцию для целой иерархии классов, 
не изменяя код этих классов.
